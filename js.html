<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="wrapper">

    <header class="page-header">
      <a href="index.html">home</a>
    </header>

    <main class="page-main">


      <section class="js">


        <div class="container">

          <h1>Javascript</h1>

          <section class="js__checks">
            <h2 class="title">Проверки</h2>

            <details class="show-piece typeof">
              <summary>typeof -- узнать тип примитивного значения</summary>
              <pre>
  <code>
 console.log(typeof 21); // => number
 console.log(typeof '21'); // => string
 console.log(typeof false); // => boolean
 console.log(typeof {}); // => object
 console.log(typeof undefined); // => undefined
 console.log(typeof null); // => object (признанный баг, который
         не исправляют ради обратной совместимости)
  </code>
</pre>
            </details>

            <details class="show-piece isNaN">
              <summary>isNaN -- является ли значение выражения числом</summary>
              <pre>
  <code>
isNaN(123) // false (число)
  
isNaN("50 рублей") // (не число) 
  </code>
</pre>
              <p>Иногда можно получить такую ошибку JavaScript — NaN — когда значение не является числом (а ожидается
                число):</p>
              <pre>
  <code>
  let a=8;
  let b="pi";
  let S=a*b; // S=NaN
  </code>
</pre>
              <p>В качестве значения переменной может быть undefined — не определено. Такое случается, когда переменная
                создана, но значение ей не присвоено:</p>
              <pre>
  <code>
   let b;
   document.write(b); // b=undefined 
  </code>
</pre>
            </details>

          </section>

          <section class="js__transformation">
            <h2 class="title">Преобразования</h2>

            <pre>
    <code>
let a = parseInt(prompt("Возраст?", '18'));
let b = Number(prompt("Вesult")); 

x = +x // к числу
x = x + '' // к строке
x = !!x // к булеву типу

x = Number(x) 
x = String(x)
x = Boolean(x)
    </code>
</pre>

            <details class="show-piece join">
              <summary>join - массив в строку</summary>
              <pre>
  <code>
let arr = [1, 2, "str", false];

arr.join(" "); // "1 2 str false" (string)
  </code>
</pre>
            </details>

            <details class="show-piece split">
              <summary>split - строка в массив</summary>
              <pre>
  <code>
let arrTwo = str.split("/"); // ["1", "2", "str", "false"] (array)
  </code>
</pre>
            </details>

            <details class="show-piece toString">
              <summary>toString - объект в строку</summary>
              <pre>
    <code>
obj.toString 
    </code>
</pre>
            </details>

            <details class="show-piece keys-values">
              <summary>keys / values - объект в массив</summary>
              <p>В стандартном конструкторе Object имеются методы keys и values с помощью которых можно
                трансформировать
                объект в массив ключей и значений</p>
              <pre>
  <code>
const car = {
  brand: 'Ford',
  color: 'blue'
}

const keys = Object.keys(car); // ['brand', 'color'] 
const values = Object.values(car); // ['Ford', 'blue'] 

  </code>
</pre>
            </details>

            <details class="show-piece nodelist-array">
              <summary>NodeList - в массив </summary>
              <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

for (const node of nodeList) {
  result.push(node);
}
  </code>
</pre>
              <p>Также у NodeList есть метод forEach</p>
              <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = [];

nodeList.forEach((node) => {
  result.push(node);
});
  </code>
</pre>
              <p>Array.from();</p>
              <pre>
  <code>
const nodeList = document.querySelectorAll('div');
const result = Array.from(nodeList);
  </code>
</pre>
              <p>spread</p>
              <pre>
  <code>
const divList = document.querySelectorAll('div');
const arr = [...divList];
  </code>
</pre>
            </details>

            <details class="show-piece parseInt">
              <summary>parseInt - строку в целое число</summary>
              <p>преобразует указанную строку в целое число. Если есть второй параметр — система счисления —
                преобразование происходит по указанному основанию системы счисления (8, 10 или 16):</p>
              <pre>
    <code>
parseInt("435") // 435
parseInt("3.14") // 3
parseInt("-7.875") // -7
parseInt("Вася") // NaN
parseInt("15" ,8) // 13

parseInt - отсекает дробную часть числа.
    </code>
</pre>
            </details>

            <details class="show-piece parseFloat">
              <summary>parseFloat - строку в дробное число</summary>
              <p>преобразует указанную строку в число с плавающей точкой (десятичной):</p>
              <pre>
    <code>
parseFloat ("435") // 435
parseFloat("3.14") // 3.14
parseFloat("-7.875") // -7.875
parseFloat ("Вася") // NaN
parseFloat ("17.5") // 17.5
    </code>
</pre>
            </details>

          </section>

          <section class="js__getElement">
            <h2 class="title">Получение элементов</h2>

            <p>Почти все методы возвращают коллекции элементов схожих с массивом но это объекты классов: Array,
              NodeList,
              HTMLCollection и т.д…</p>

            <details class="show-piece element">
              <summary>element</summary>
              <pre>
    <code>
let e = document.querySelector('#nav').querySelector('ul.menu__list > li[name="li"] + li');
console.log(e); // element

let eId = document.getElementById('menu__item-3');
console.log(eId); // element
    </code>
</pre>
            </details>

            <details class="show-piece nodeList">
              <summary>NodeList - статическая коллекция элементов</summary>
              <pre>
    <code>
let eAll = document.querySelectorAll('li');
console.log(eAll); // NodeList
console.log(eAll[0]); // element

let eName = document.getElementsByName('li'); //динамическая коллекция
console.log(eName); // NodeList
console.log(eName[1]);// element

let e = list.childNodes; //динамическая коллекция
хранит в себе псевдомассив дочерних узлов
элемента (теги, комментарии и текстовые узлы).
    </code>
</pre>
            </details>

            <details class="show-piece htmlCollection">
              <summary>HTMLCollection - динамическая коллекция элементов</summary>
              <pre>
    <code>
let eTag = document.getElementsByTagName('li');
console.log(eTag); // HTMLCollection
console.log(eTag[2]); // element

let eClass = document.getElementsByClassName('menu__item');
console.log(eClass); // HTMLCollection
console.log(eClass[3]); // element
    </code>
</pre>
            </details>

          </section>

          <section class="js__cycles">
            <h2 class="title">циклы</h2>

            <details class="show-piece for">
              <summary>for</summary>
              <p>пройти n раз свойства или значения</p>
              <p>i внутри for не индекс, это просто счетчик который совпадает с индексами на каждой итерации начиная с
                <code>let i = 0;</code>
              </p>
              <pre>
 <code>
for (let i = 0; i < arr.length; i++) {
  console.log(i); //ключи
  console.log(arr[i]); //значения
}
 </code>
</pre>
            </details>

            <details class="show-piece for-in">
              <summary>for-in</summary>
              <p>перебор всех свойств или значений // только obj</p>
              <pre>
 <code>
 for (let key in obj) {
  console.log(key); //свойства
  console.log(obj[key]); //значения
 }
 </code>
</pre>
            </details>

            <details class="show-piece for-of">
              <summary>for-of</summary>
              <p>перебор всех значений // только значений</p>
              <pre>
 <code>
 for (let i of arr) {
  console.log(i) //значения
 }
    
 for of работает сразу со значениями:
    
 iter - строка/массив/объект/и т.д.

 let iter = [ 2, 4, 9, "9" ];

 for (let i of iter) {
  i += 1; ----- for of может изменять значения прям на ходу потому
  console.log(i);           что работает сразу со значениями
 }
 // 3
 // 5
 // 10
 // "91" —- string (произошел concat)
 </code>
</pre>
            </details>

          </section>

          <section class="structures">
            <h2 class="title">структуры данных</h2>


            <details class="show-piece primitives">
              <summary>примитивы</summary>
              <p>Все кроме объекта являются примитивными.</p>
              <p>Примитивы неизменны, строку можно только перезаписать полностью. JavaScript
                неявно оборачивает примитив в объект его типа, так что на примитивах возможно использовать свойства и
                методы этих объектов.</p>
              <p>Number, BigInt, String, Boolean, null, undefined, Symbol, Object.</p>
            </details>

            <details class="show-piece string">
              <summary>string</summary>
              <p>Объект класса String</p>
              <p>cтрока - примитив, приметив неизменяем(только заменяем).</p>
              <pre>
    <code>
let str = "Строковой литерал"; //string
let str = new String("Объект класса String"); //object
 
 
let str = "How are you?"; //string
 
   "H  o  w     a  r  e     y  o  u  ?";
    0  1  2  3  4  5  6  7  8  9  10 11
пробел тоже символ по этому у него есть индекс.
    </code>
</pre>
              <p>доступ к символам:</p>
              <pre>
    <code>
let str = "JavaScript";

str[0] // J str[index] -- es5
str.charAt(0) // J
str.at(0) // J -- Array.prototype.at

console.log(str[str.length - 1]); // t
console.log(str.at(-1)); // t
    </code>
</pre>
              <p>charAt() или []</p>
              <pre>
    <code>
если на месте искомой позиции символа нет:
  - charAt() вернет пустую строку ''
  - [] – вернет undefined.
    </code>
</pre>

              <div class="performance">
                <h2>Методы String</h2>

                <ul class="list-reset">
                  <li>at() -- возвращает символ</li>
                  <li>charAt() and slice() возвращает строковые значения на основе индексов</li>
                  <li>indexOf() and lastIndexOf() вернут индексы на основе значений</li>


                  <li>charCodeAt() -- возвращает числовое значение Юникода для символа по индексу</li>
                  <li>codePointAt() -- возвращает неотрицательное целое число, являющееся закодированным в UTF-16
                    значением кодовой точки</li>

                  <li>concat() -- объединяет</li>

                  <li>startsWith() -- начинается ли строка с символов указанных в скобках</li>
                  <li>endsWith() -- заканчивается ли строка символами указанными в скобках</li>

                  <li>includes() -- проверяет, содержит ли строка заданную подстроку</li>
                  <li>indexOf() -- возвращает индекс первого вхождения</li>
                  <li>lastIndexOf() -- возвращает индекс последнего вхождения</li>
                  <li>match()-- возвращает совпадения с регулярным выражением</li>

                  <li>padStart() -- дополняет текущую строку с начала</li>
                  <li>padEnd() -- дополняет текущую строку с конца</li>

                  <li>repeat() -- конструирует и возвращает новую строку</li>

                  <li>replace() -- замена части</li>


                  <li>search() -- возвращает индекс первого сопоставления с регулярным выражением внутри строки.</li>

                  <li>split() -- разбивает объект String на массив строк</li>

                  <li>toLocaleLowerCase() / toLocaleUpperCase() / toLowerCase() / toUpperCase()</li>
                  <li>valueOf() возвращает примитивное значение объекта String.</li>

                  <li>toString() возвращает строку, представляющую объект и делает тоже самое, что и метод
                    String.prototype.valueOf().</li>

                  <li>trim() удаляет пробельные символы с начала и конца строки</li>

                </ul>

                <details class="show-piece charAt">
                  <summary>charAt -- возврата символа</summary>
                  <p>метод для возврата символа, используя индекс в качестве параметра</p>
                  <pre>
 <code>
"How are you?".charAt(5); //r
 </code>
</pre>
                </details>

                <details class="show-piece indexOf">
                  <summary>indexOf -- поиск подстроки</summary>
                  <p>ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию совпадения, либо -1
                    при отсутствии совпадений.</p>
                  <p>чувствителен к регистру</p>
                  <p>вернет порядковый номер первого символа в экземпляре.</p>
                  <pre>
 <code>
let str = 'Widget with id';
 
alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
 
alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
это если не указать второй параметр, если указать индекс
дальше позиции 2 то он найдет другое совпадение
 
Необязательный второй аргумент позволяет начать поиск с
определённой позиции.
str.indexOf("id", 2); // 12
 </code>
</pre>

                  <p>Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив
                    очередную
                    позицию, начинаем
                    новый поиск со следующей:</p>

                  <pre>
 <code>
let str = 'Ослик Иа-Иа посмотрел на виадук';
 
let target = 'Иа'; // цель поиска
 
let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;
 
  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
 
Тот же алгоритм можно записать и короче:
 
let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";
 
let pos = -1;
  while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
 </code>
</pre>
                </details>

                <details class="show-piece includes">
                  <summary>includes(substr, pos) -- возвращает boolean</summary>
                  <p>возвращает true, если в строке str есть подстрока substr, либо false</p>
                  <p>если нам необходимо проверить, есть ли совпадение, но позиция не нужна</p>
                  <pre>
<code>
alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye") ); // false
 
второй аргумент позволяет начать поиск с определённой позиции
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
</code>
  </pre>
                </details>

              </div>

              <div class="performance">
                <h2>Получение подстроки</h2>
                <p>В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.</p>

                <details class="show-piece slice">
                  <summary>slice(start [, end]) -- возвращает часть строки</summary>
                  <pre>
<code>
"How are you?".slice(8, 11); //you
      
            индексы символов:  0 1 2 3 4 5 6 7 8
                              ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
            индексы slice:    0 1 2 3 4 5 6 7 8 9

Если аргумент end отсутствует, slice возвращает символы до конца строки.
</code>
</pre>
                </details>
              </div>


            </details>

            <details class="show-piece function">
              <summary>function</summary>
              <p>объект класса Function</p>
              <p>Функция – особого типа значение переменной</p>

              <div class="performance">
                <h3 class="performance__title">Function Declaration - объявление функции</h3>

                <p>может быть вызвана раньше, чем она объявлена.</p>
                <p>доступна везде внутри блока в котором находится, но не снаружи него</p>
                <p>инструкция определяет переменную (имя функции) и назначает ей ссылку на функцию. Объявления функций
                  не
                  являются
                  частью обычной
                  последовательности выполнения программ. Они перемещаются в верхнюю часть своей области видимости.</p>
                <pre>
    <code>
function sayHi() {
  console.log("Привет");
}
sayHi(); //Привет
    </code>
</pre>

              </div>

              <div class="performance">
                <h3>Function Expression - функциональное выражение</h3>
                <p>создаётся, когда выполнение доходит до него.</p>
                <pre>
    <code>
let sayHi = function() {
   console.log("Привет");
}
sayHi(); //Привет
    </code>
</pre>
              </div>

              <div class="performance">
                <h3>стрелочные</h3>
                <pre>
  <code>
(...args) => expression

(...args) => { return } если использовать скобки то надо явно указать return

return без следующего за ним выражения приводит к тому что функция возвращает undefined

одна и та же функция:
const square = (x) => {return x * x};
const square = x => x * x;
  </code>
</pre>
              </div>
            </details>

            <details class="show-piece htmlCollection">
              <summary>HTMLCollection</summary>
              <p>объект класса HTMLCollection</p>
              <p>getElementsBy...</p>
              <ul>
                <li>Динамическая коллекция элементов</li>
                <li>Не имеет привычных методов массива</li>
                <li>Хранит только узлы HTML элементов(теги)</li>
                <li>Обращение к элементам коллекции:
                  <ul>
                    <li>по индексу</li>
                    <li>по имени методом namedItem</li>
                  </ul>
                </li>
              </ul>

              <p>если возвращенная коллекция динамическая то перебирать ее нужно с конца (страница 274)</p>
            </details>

            <details class="show-piece nodeList">
              <summary>NodeList</summary>
              <p>объект класса NodeList</p>
              <p>querySelectorAll / getElementsByName / childNodes</p>
              <ul>
                <li>статическая / динамическая коллекция элементов</li>
                <li>не имеет привычных методов массива</li>
                <li>хранит любые типы узлов(текстовые узлы и комментарии)</li>
                <li>обращение к элементам коллекции только по индексу</li>
              </ul>
            </details>

            <details class="show-piece array">
              <summary>array</summary>
              <h2>объект класса Array</h2>
              <ul>
                <li>списки пронумерованных значений</li>
                <li>могут содержать данные любого типа</li>
                <li>многие методы массива будут влиять на исходный массив, а не на его копию</li>
              </ul>
              <pre>
  <code>
const a = []
const a = [1, 2, 3]
const a = Array.of(1, 2, 3)
const a = Array(6).fill(1) // 6 элементов c числом 1
</code>
</pre>
              <h3>Доступ к элементам по индексам arr[index]</h3>
              <pre>
   <code>
let arr = [10, "2", 3, false];
let first = arr[0];
let count = 1;

arr[0] и arr.at(0) оба вернут первый элемент

console.log(arr[3]); // false
console.log(first); // 10
console.log(arr[count]) // "2"
  </code>
</pre>

              <p>При использовании точки слово, стоящее после нее, является точечным именем свойства.</p>
              <p>При использовании квадратных скобок,для получении имени свойства
                <i>Вычисляется</i> заключенное в скобки выражение.
              </p>
              <p>Если value.x извлекает из значения value свойство с именем x, то
                value[x] пытается вычислить выражение x и применяет результат, преобразованный в строку, в качестве
                имени
                свойства</p>
              <p>По этому если вы знаете что интересующее вас свойство называется color, то пишите сразу value.color
              </p>
              <h3>replacement</h3>
              <pre>
   <code>
arr[0] = 4
console.log(a) //[4, "2", 3, false];
   </code>
</pre>

              <h3>add</h3>
              <pre>
  <code>
a[5] = false;
console.log(arr) //[ 4, "2", 3, false "", false ] // Разреженный массив
  </code>
</pre>

              <h3>Обращение к несуществующему элементу вернет undefined</h3>
              <pre>
   <code>
console.log(arr[7]); // undefined
   </code>
</pre>


              <details class="show-piece array-clone">
                <summary>Клонирование массива</summary>
                <p>В js нет метода для клонирования массивов</p>
                <p>Этот метод легко сэмулировать, помня, что concat и slice не меняют исходный массив. Достаточно
                  вызвать
                  метод
                  concat без
                  аргументов или метод slice с единственным аргументом равным 0.</p>
                <pre>
   <code>
let a = [1,2,3];
let b = a.concat();
let c = a.slice(0);

(a + ';' + b + ';' + c); // '1,2,3;1,2,3;1,2,3'

([a == b, a == c, b == c]); // [ false,false,false ]
   </code>
</pre>
                <p>Если в массиве лежат ссылки на объекты, в том числе ссылки на другие массивы, то в новосозданном
                  массиве будут лежать
                  ссылки на те же самые объекты. Поэтому если вы хотите клонировать многомерный массив, то
                  придётся
                  вручную создавать
                  новый массив, после чего перебрать подмассивы исходного массива и клонировать их в новый.</p>
                <pre>
   <code>
  Клонируется только массив верхнего уровня:
let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = a.concat();

a[0][1] // 2
b[0][1] // 2

b[0][1] = 15;
a[0][1] // 15
   </code>
</pre>
                <pre>
   <code>
  Клонируем вложенные массивы:

let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = [ ];
  a.forEach(function(subArry) {
  b.push(subArray.concat());
})

a[0][1]; // 2
b[0][1]; // 2

b[0][1] = 15;
a[0][1]; // 15
   </code>
</pre>


              </details>

              <div class="performance">

                <h2>Методы массивов</h2>

                <details class="show-piece reverse">
                  <summary>Array.indexOf</summary>
                  Array.indexOf — ищет только 1 символ
                  String.indexOf — может искать строку больше 1 символа
                </details>

                <details class="show-piece reverse">
                  <summary>reverse - разворачивает</summary>
                  <p>изменяет исходный массив</p>

                  <pre>
  <code>
let a = [ ];

a[1] = 1;
b[2] = 2;

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // ,1,2, : false,true,true

a.reverse();

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // 2,1, : true,true,false
  </code>
</pre>
                </details>

                <details class="show-piece sort">
                  <summary>sort - сортирует</summary>
                  <p>изменяет исходный массив</p>
                  <p>принимает единственным аргументом функцию, сравнивающую элементы массива. Если функция
                    сравнения не
                    задана, то элементы
                    сортируются в лексикографическом порядке.</p>
                  <pre>
   <code>
 var a = ['d', 'b', 'a', 'e', 'c'];
 a.sort();
 alert(a); // a,b,c,d,e
   </code>
</pre>
                  <p>без переданной callback -функции, если сортировать числа, sort отсортирует их как строки,
                    а не как
                    числа.</p>
                  <pre>
   <code>
 let a = [4, 2, 10, 5, 30];
 a.sort(); // 10,2,30,4,5
   </code>
</pre>
                  <p>для сортировки чисел необходимо передать методу sort функцию сравнения двух чисел (a - b)
                    / (a + b)
                  </p>
                  <pre>
   <code>
 let arr = [ 3, 22, -10, 1, 7 ]

 без callback - функции
 arr.sort(); // [-10, 1, 22, 3, 7] - сортирует в лексикографическом порядке

 с функцией сравнения
 arr.sort((a-b) => a - b); // [-10, 1, 3, 7, 22] - сортирует по порядку
   </code>
</pre>
                </details>

                <details class="show-piece concat">
                  <summary>concat</summary>
                  <p>создаёт копию исходного массива, добавляя к нему переданные аргументы</p>
                  <pre>
   <code>
 Array.prototype.toString = function() {
   return '[' + this.join(,) + ']';
 };


 let a = [1,2,3];

 a.concat(4,5,6); //[1,2,3,4,5,6]

 a.concat([4,5],[6]); //[1,2,3,4,5,6]
   </code>
</pre>
                  <p>Однако дальше одного уровня concat аргументы-массивы не разворачивает</p>
                  <pre>
   <code>
 a.concat([4, [5], 6]); //[1,2,3,4,[5],6]
   </code>
</pre>
                  <p>пропуски как из исходного массива, так и из массивов-аргументов, сохраняются</p>
                  <pre>
   <code>
 let a = [1, , 3];

 console.log(a.concat([4, , 6])); // [1, , 3, 4, , 6]
   </code>
</pre>
                </details>

                <details class="show-piece slice">
                  <summary>slice - возвращает подмассив исходного массива</summary>
                  <p>slice(begin[, end])</p>
                  <p>возвращает подмассив исходного массива, начиная с индекса begin и заканчивая индексом end
                    - 1.</p>
                  <p>метод массива с помощью которого можно получить копию части или всего массива</p>
                  <p>Чтобы легче запомнить такую странную нумерацию, лучше считать, что передаются индексы не
                    элементов,
                    а "межэлементного пространства".</p>
                  <pre>
   <code>
 индексы элементов: 0 1 2 3 4 5 6 7 8
                   ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
 индексы slice:    0 1 2 3 4 5 6 7 8 9
   </code>
</pre>
                  <p>становится понятно, что ar.slice(0, 1) вернёт только нулевой элемент, а slice(5, 9) — с
                    пятого по
                    восьмой элементы.</p>
                  <pre>
   <code>
let arr = [0, 1, 2, 3, 4, 5];

arr.slice(0, 2); // 0,1
arr.slice(4, 5); // 4
   </code>
</pre>
                  <p>Если второй аргумент является отрицательным числом, то отсчёт второго индекса идёт с конца
                    массива.
                  </p>
                  <pre>
  <code>
arr.slice(0, -2); // 0,1,2,3 
  </code>
</pre>
                  <p>Если же второй аргумент не передан вообще, то возвращается копия массива от begin до
                    конца.</p>
                  <pre>
   <code>
arr.slice(3); // 3,4,5
   </code>
</pre>
                </details>

              </div>













            </details>

            <details class="show-piece object">
              <summary>object</summary>
              <p>Объекты для хранения именованных коллекций</p>
              <p>Объекты – это ссылочный тип, когда вы присваиваете объект переменной, вы присваиваете ей не сам этот
                объект, а ссылку на него, которая указывает на то место в памяти компьютера, где он находится.</p>
              <pre>
<code>
const person = {
name: 'Игорь',      // свойство : значение
  getFullName() {   // метод
    return `${this.name}`
  },
}
 </code>
</pre>

              <div class="performance">
                <h3>свойства</h3>
                <ul>
                  <li>свойства это пары ключ: значение</li>
                  <li>свойства объекта неявно имеют строковый тип</li>
                  <li>свойства это характеристики объекта</li>
                  <li>свойства подобны переменным, но в составе объекта</li>
                </ul>
                <h3>методы</h3>
                <ul>
                  <li>Методы – это поведение объекта, его функции</li>
                  <li>Методы – это свойства, у которых значение является функцией</li>
                </ul>
              </div>

              <div class="performance">
                <h3>имена свойств в объекте не явно являются строками.</h3>
                <p>Их можно не заключать в кавычки, это допустимо только если они составлены по правилам именования
                  переменных
                </p>
                <pre>
 <code>
{
  '': 1, // имя является пустой строкой
  'author of post': 'Алексей', // имя состоит из нескольких слов
}
 </code>
</pre>
              </div>

              <div class="performance">
                <h3>Обращение к свойствам</h3>
                <pre>
 <code>
через точку:
person.firstName;
 
через квадратные скобки, ключ в этом случае нужно указывать в виде строки:
person['name'];
 
 
разница в том что через . мы не можем обратиться к нестандартному свойству, 
например которое состоит из двух слов или имеет тип nember:
 
person["new prop"] = "bateman";

obj[3] 
 </code>
</pre>
              </div>

              <div class="performance">
                <h3>обращение к методам</h3>
                <pre>
  <code>
const getName = person.getFullName();
 
getName;
person.getFullName();
person['getFullName']();
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>добавление свойств</h3>
                <pre>
  <code>
person.age= 18;
person["last name"] = "Рыбинский";
person.children = [
  {
    name: 'Алиса',
    age: 8
  },
  {
    name: 'Виктор',
    age: 14
  }
];
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>изменим значения свойств</h3>
                <pre>
  <code>
person.name= 'Иван';
person["new prop"] = "money";
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>Удаление свойств</h3>
                <pre>
  <code>
delete person.age;
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>Проверить наличия ключа</h3>
                <pre>
  <code>
'name' in person // true
'middleName' in person // false
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>перебор объекта</h3>
                <pre>
  <code>
Object.keys(car).forEach((key) => {
  console.log(`${key}: ${car[key]}`);
});
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>Если нужно перебрать только значения, то так:</h3>
                <pre>
  <code>
Object.values(car).forEach((value) => {
  console.log(value);
});
  </code>
</pre>
              </div>

              <div class="performance">
                <h3>entries</h3>
                <p>в Object имеется также метод entries, массив массивов, в котором первый элемент будет
                  являться
                  именем
                  свойства, а второй значением:</p>
                <pre>
  <code>
const car = {
  brand: 'Ford',
  color: 'blue'
}
const entries = Object.entries(car); // [['brand', 'Ford'], ['color', 'blue']]
  entries.forEach((item) => {
  console.log(`${item[0]}: ${item[1]}`);
});
  </code>
</pre>
              </div>

              <div class="performance">
                <h2>методы объектов</h2>
                <p>delete key — удалит значение</p>
                <p>key in obj — проверка наличия ключа</p>
                <p>obj.keys — вернет массив ключей</p>
                <p>obj.assign — копирует все свойства</p>
              </div>

              <div class="performance">
                <details class="show-piece object-clone">
                  <summary>Копирование объектов</summary>
                  <p>Переменная, содержащая объект на самом деле содержит не сам объект, а только ссылку на него. При
                    копировании объектов в отличие от значений примитивных типов происходит передача ссылки.</p>
                  <pre>
  <code>
const student1 = { name: 'Carl' };
const student2 = student1;

Теперь student1 и student2 содержат ссылки, 
указывающие на один и тот же объект.

student2.name = 'Nelly';
console.log(student1.name); // Nelly
 </code>
</pre>
                  <p>А что если нам необходимо скопировать не саму ссылку, а создать новый объект с такими же
                    свойствами?
                  </p>
                  <pre>
 <code>
const student3 = {};
for (const key in student1) {
  student3[key] = student1[key];
}

student3 содержит клон объекта student1
student3.name = 'Thyra';
в student1 значение name осталось прежним
console.log(student1.name); // Nelly
 </code>
</pre>

                  <h3>Другой способ скопировать свойства:</h3>
                  <pre>
 <code>
const student4 = Object.assign({}, student1);
 </code>
</pre>

                  <p>Object.assign() позволяет скопировать свойства из множества объектов.</p>
                  <pre>
 <code>
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
console.log(target); // {a: 1, b: 2, c: 3}
 </code>
</pre>

                  <h2>Сравнение объектов</h2>
                  <pre>
 <code>
let objA = {};
let objB = objA;
let objC = {};

console.log( objA === objB ); // true, т.к. переменные содержат одну и ту же ссылку
console.log( objA === objC ); // false, т.к. переменные содержат разные ссылки (оба объекта пусты, но это разные объекты)
 </code>
</pre>
                </details>

                <details class="show-piece">
                  <summary>Вычисляемые свойства</summary>
                  <p>В JavaScript имя свойства может быть вычисляемым. То есть для задания имени можно использовать
                    выражение, результат вычисления которого и будет это имя. Указывать вычисляемое свойство необходимо
                    в
                    квадратных скобках [ ]:</p>
                  <pre>
  <code>
const key = 'url';
const app = {
  name: 'Yandex',
  [key]: 'https://yandex.ru/', // имя свойства будет взято из переменной key
};
console.log(app.url); // 'https://yandex.ru/'
 </code>
</pre>

                  <h3>метод с более сложным выражением:</h3>
                  <pre>
  <code>
const key = 'url';
const app = {
  name: 'Yandex',
  [key]: 'https://yandex.ru/',
  ['get' + key.toUpperCase()]() {
    return this[key];
  }
};
console.log(app.getURL()); // 'https://yandex.ru/'
 </code>
</pre>
                </details>

                <details class="show-piece object-properties">
                  <summary>Свойства объектов и их конфигурация</summary>
                  <a href="https://itchief.ru/javascript/objects" target="_blank" rel="noopener noreferrer">источник
                    https://itchief.ru/javascript/objects</a>

                  <p>До этого времени мы рассматривали свойства как пары «ключ: значение».</p>
                  <p>Но свойство кроме значения (value) имеет специальные флаги:</p>
                  <ul>
                    <li>writable – доступно ли свойство для изменения;</li>
                    <li>enumerable – доступно ли свойство для перебора в циклах;</li>
                    <li>configurable – доступно ли свойство для настройки и удаления.</li>
                  </ul>


                </details>
              </div>




            </details>

            <details class="show-piece map">
              <summary>map</summary>
            </details>

            <details class="show-piece set">
              <summary>set</summary>
            </details>

          </section>

          <section class="js__logical-operators">
            <details class="show-block logical-operators">
              <summary><code>Логические операторы</code></summary>

              <details class="show-piece">
                <summary><code>?</code></summary>
                <p>имеет три аргумента</p>
                <pre>
  <code>
let result = условие ? значение1 : значение2;
  </code>
</pre>
                <p>Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае –
                  значение2.</p>

                <pre>
  <code>
let accessAllowed = (age &gt; 18) ? true : false;
  </code>
</pre>
                <p>Технически, мы можем опустить круглые скобки вокруг age &gt; 18. Оператор вопросительного знака
                  имеет
                  низкий
                  приоритет,
                  поэтому он выполняется после сравнения &gt;.</p>
                <pre>
  <code>
let accessAllowed = age &gt; 18 ? true : false;
  </code>
</pre>

                <p>обычная последовательная проверка</p>
                <pre>
  <code>
let age = prompt('Возраст?', 18);

let message = (age &lt; 3) ? 'Здравствуй, малыш!' : 
              (age &lt; 18) ? 'Привет!' : 
              (age &lt; 100) ? 'Здравствуйте!' : 'Какой необычный возраст!' ; 

alert( message );     
  </code>
</pre>


                <pre>
  <code>
Вот как это выглядит при использовании if..else:

if (age &lt; 3) { 
  message='Здравствуй, малыш!' ; 
} else if (age &lt; 18) { 
  message='Привет!' ; 
} else if (age &lt; 100) {
  message='Здравствуйте!' ; 
} else { 
  message='Какой необычный возраст!' ; 
}
  </code>
</pre>

              </details>

              <details class="show-piece">
                <summary><code>||</code> -- или</summary>
                <p>возвращает первое истинное значение или последнее</p>
                <pre>
  <code>
result = a || b; //если первый операнд вернет true то второй не вычисляется
  </code>
</pre>
                <p>Существует всего четыре возможные логические комбинации:</p>
                <pre>
  <code>
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
  </code>
</pre>
                <p>Если значение не логического типа, то оно к нему приводится в целях вычислений.</p>
                <pre>
  <code>
    цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "John" – первое истинное значение

Если бы и currentUser, и defaultUser были ложными, в качестве результата мы бы наблюдали "unnamed".
  </code>
</pre>

                <p>ИЛИ || вычисляет слева направо. Вычисление останавливается при достижении первого истинного
                  значения.
                  Этот
                  процесс
                  называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае,
                  если
                  первого
                  недостаточно для вычисления всего выражения.</p>
                <pre>
  <code>
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется

Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:

let x;

false || (x = 1);

alert(x); // 1


этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается
ложным, начинается вычисление второго.
  </code>
</pre>
              </details>





              <details class="show-piece">
                <summary><code></code></summary>

              </details>





              <details class="show-piece">
                <summary><code></code></summary>

              </details>




              <details class="show-piece">
                <summary><code></code></summary>

              </details>



            </details>
          </section>


        </div>
      </section> <!-- js -->

    </main>

    <footer class="page-footer"></footer>
  </div>
</body>

</html>